# データエンコード

第２章ではエコークライアント／サーバーはデータの中身を調べずに、バイト数をカウントして次の処理を決めるという単純な仕様だったため、プリケーションプロトコルは出る幕がなかった。この章では、データエンコードに焦点を当てることにする。メッセージフォーマット解析には様々な落とし穴があるが、エンコードを理解していれば、そのうちいくつかは避けることが出来る。

例えば２つの数値を別々のプログラムへ送信するプログラムについて考える。１つ目の数値はある銀行口座にその日にあずれられた金額の合計とする。もう一つのあたいは、引き出された金額の合計とする。この例では、送信側と受信側の２つのプログラムが第一に確認しなければならないのは、この２つのデータ表現方法である。さもないと残高に矛盾が生じる。

## データエンコード

引き出し金額の合計、および預入金額の合計の表現方法として考えられるのは、ASCIIコードで2つのフィールドで構成するメッセージを受け取ることである。

```c
sprintf("msgBuffer", "%d %d ", deposits, withdrawals);
send(s, msgBuffer, strlen(msgBuffer), 0);
```

ここで気をつけなければならないのは、以下の3点

- sprintfにわたすフォーマット文字列の末尾は空白文字が入る。これはプロトコルの制約であり、区切り文字がないと、フィールド範囲を指定できない。
- msgBufferには、処理結果がどのような大きさになっても格納できるサイズを確保する必要がある。
- sendの送信サイズは、msgBufferと全く同じサイズである必要がある。なのでこれは構文として覚えてしまった方が良い。

文字列ではなく数値でやり取りする場合は、以下のようにint型をそのまま送受信する。

```c
struct
{
    int dep;
    int wd;
} msgStruct;

    msgStruct.dep = 10;
    msgStruct.wd = 20;
    send(s, &msgStruct, sizeof(msgStruct), 0);
```

TCPを使う限りにおいては、次に示すようにそのまま数値を送信しても良い。

```c
    send(s, &deposits, sizeof(deposits), 0);
    send(s, &withdrawals, sizeof(withdrawals), 0);
```

ただしUDPは独立した２つのデータグラムが生成されてしまうめ、これは出来ない。

## 配列とパディング

メッセージに複数のバイナリエンコードされたフィールドがあり、各フィールドのサイズが事なr場合には、アプリケーションプロトコルでフィールドの境界を考慮する必要がある。

```
|    預け入れ額    | 預け入れ回数 |    引き出し値    | 引き出し回数 |
|     4バイト      |   2バイト   |     4バイト      |   2バイト   |
```

```c
struct msgBuf
{
    int centsDeposited;
    unsigned short numDeps;
    int centsWithdrawn;
    unsigned short numWds;
};

    send(s, &msgBuf, sizeof(msg), 0);
```

